// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'stats_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$StatsEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadStats,
    required TResult Function(Book book) bookFinished,
    required TResult Function(Book book) bookUnfinished,
    required TResult Function() bookStarted,
    required TResult Function() bookUnstarted,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadStats,
    TResult? Function(Book book)? bookFinished,
    TResult? Function(Book book)? bookUnfinished,
    TResult? Function()? bookStarted,
    TResult? Function()? bookUnstarted,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadStats,
    TResult Function(Book book)? bookFinished,
    TResult Function(Book book)? bookUnfinished,
    TResult Function()? bookStarted,
    TResult Function()? bookUnstarted,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadStats value) loadStats,
    required TResult Function(BookFinished value) bookFinished,
    required TResult Function(BookUnfinished value) bookUnfinished,
    required TResult Function(BookStarted value) bookStarted,
    required TResult Function(BookUnstarted value) bookUnstarted,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadStats value)? loadStats,
    TResult? Function(BookFinished value)? bookFinished,
    TResult? Function(BookUnfinished value)? bookUnfinished,
    TResult? Function(BookStarted value)? bookStarted,
    TResult? Function(BookUnstarted value)? bookUnstarted,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadStats value)? loadStats,
    TResult Function(BookFinished value)? bookFinished,
    TResult Function(BookUnfinished value)? bookUnfinished,
    TResult Function(BookStarted value)? bookStarted,
    TResult Function(BookUnstarted value)? bookUnstarted,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $StatsEventCopyWith<$Res> {
  factory $StatsEventCopyWith(
          StatsEvent value, $Res Function(StatsEvent) then) =
      _$StatsEventCopyWithImpl<$Res, StatsEvent>;
}

/// @nodoc
class _$StatsEventCopyWithImpl<$Res, $Val extends StatsEvent>
    implements $StatsEventCopyWith<$Res> {
  _$StatsEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of StatsEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$LoadStatsImplCopyWith<$Res> {
  factory _$$LoadStatsImplCopyWith(
          _$LoadStatsImpl value, $Res Function(_$LoadStatsImpl) then) =
      __$$LoadStatsImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadStatsImplCopyWithImpl<$Res>
    extends _$StatsEventCopyWithImpl<$Res, _$LoadStatsImpl>
    implements _$$LoadStatsImplCopyWith<$Res> {
  __$$LoadStatsImplCopyWithImpl(
      _$LoadStatsImpl _value, $Res Function(_$LoadStatsImpl) _then)
      : super(_value, _then);

  /// Create a copy of StatsEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadStatsImpl implements LoadStats {
  const _$LoadStatsImpl();

  @override
  String toString() {
    return 'StatsEvent.loadStats()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadStatsImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadStats,
    required TResult Function(Book book) bookFinished,
    required TResult Function(Book book) bookUnfinished,
    required TResult Function() bookStarted,
    required TResult Function() bookUnstarted,
  }) {
    return loadStats();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadStats,
    TResult? Function(Book book)? bookFinished,
    TResult? Function(Book book)? bookUnfinished,
    TResult? Function()? bookStarted,
    TResult? Function()? bookUnstarted,
  }) {
    return loadStats?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadStats,
    TResult Function(Book book)? bookFinished,
    TResult Function(Book book)? bookUnfinished,
    TResult Function()? bookStarted,
    TResult Function()? bookUnstarted,
    required TResult orElse(),
  }) {
    if (loadStats != null) {
      return loadStats();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadStats value) loadStats,
    required TResult Function(BookFinished value) bookFinished,
    required TResult Function(BookUnfinished value) bookUnfinished,
    required TResult Function(BookStarted value) bookStarted,
    required TResult Function(BookUnstarted value) bookUnstarted,
  }) {
    return loadStats(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadStats value)? loadStats,
    TResult? Function(BookFinished value)? bookFinished,
    TResult? Function(BookUnfinished value)? bookUnfinished,
    TResult? Function(BookStarted value)? bookStarted,
    TResult? Function(BookUnstarted value)? bookUnstarted,
  }) {
    return loadStats?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadStats value)? loadStats,
    TResult Function(BookFinished value)? bookFinished,
    TResult Function(BookUnfinished value)? bookUnfinished,
    TResult Function(BookStarted value)? bookStarted,
    TResult Function(BookUnstarted value)? bookUnstarted,
    required TResult orElse(),
  }) {
    if (loadStats != null) {
      return loadStats(this);
    }
    return orElse();
  }
}

abstract class LoadStats implements StatsEvent {
  const factory LoadStats() = _$LoadStatsImpl;
}

/// @nodoc
abstract class _$$BookFinishedImplCopyWith<$Res> {
  factory _$$BookFinishedImplCopyWith(
          _$BookFinishedImpl value, $Res Function(_$BookFinishedImpl) then) =
      __$$BookFinishedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Book book});
}

/// @nodoc
class __$$BookFinishedImplCopyWithImpl<$Res>
    extends _$StatsEventCopyWithImpl<$Res, _$BookFinishedImpl>
    implements _$$BookFinishedImplCopyWith<$Res> {
  __$$BookFinishedImplCopyWithImpl(
      _$BookFinishedImpl _value, $Res Function(_$BookFinishedImpl) _then)
      : super(_value, _then);

  /// Create a copy of StatsEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? book = null,
  }) {
    return _then(_$BookFinishedImpl(
      null == book
          ? _value.book
          : book // ignore: cast_nullable_to_non_nullable
              as Book,
    ));
  }
}

/// @nodoc

class _$BookFinishedImpl implements BookFinished {
  const _$BookFinishedImpl(this.book);

  @override
  final Book book;

  @override
  String toString() {
    return 'StatsEvent.bookFinished(book: $book)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BookFinishedImpl &&
            (identical(other.book, book) || other.book == book));
  }

  @override
  int get hashCode => Object.hash(runtimeType, book);

  /// Create a copy of StatsEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BookFinishedImplCopyWith<_$BookFinishedImpl> get copyWith =>
      __$$BookFinishedImplCopyWithImpl<_$BookFinishedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadStats,
    required TResult Function(Book book) bookFinished,
    required TResult Function(Book book) bookUnfinished,
    required TResult Function() bookStarted,
    required TResult Function() bookUnstarted,
  }) {
    return bookFinished(book);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadStats,
    TResult? Function(Book book)? bookFinished,
    TResult? Function(Book book)? bookUnfinished,
    TResult? Function()? bookStarted,
    TResult? Function()? bookUnstarted,
  }) {
    return bookFinished?.call(book);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadStats,
    TResult Function(Book book)? bookFinished,
    TResult Function(Book book)? bookUnfinished,
    TResult Function()? bookStarted,
    TResult Function()? bookUnstarted,
    required TResult orElse(),
  }) {
    if (bookFinished != null) {
      return bookFinished(book);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadStats value) loadStats,
    required TResult Function(BookFinished value) bookFinished,
    required TResult Function(BookUnfinished value) bookUnfinished,
    required TResult Function(BookStarted value) bookStarted,
    required TResult Function(BookUnstarted value) bookUnstarted,
  }) {
    return bookFinished(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadStats value)? loadStats,
    TResult? Function(BookFinished value)? bookFinished,
    TResult? Function(BookUnfinished value)? bookUnfinished,
    TResult? Function(BookStarted value)? bookStarted,
    TResult? Function(BookUnstarted value)? bookUnstarted,
  }) {
    return bookFinished?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadStats value)? loadStats,
    TResult Function(BookFinished value)? bookFinished,
    TResult Function(BookUnfinished value)? bookUnfinished,
    TResult Function(BookStarted value)? bookStarted,
    TResult Function(BookUnstarted value)? bookUnstarted,
    required TResult orElse(),
  }) {
    if (bookFinished != null) {
      return bookFinished(this);
    }
    return orElse();
  }
}

abstract class BookFinished implements StatsEvent {
  const factory BookFinished(final Book book) = _$BookFinishedImpl;

  Book get book;

  /// Create a copy of StatsEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BookFinishedImplCopyWith<_$BookFinishedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BookUnfinishedImplCopyWith<$Res> {
  factory _$$BookUnfinishedImplCopyWith(_$BookUnfinishedImpl value,
          $Res Function(_$BookUnfinishedImpl) then) =
      __$$BookUnfinishedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Book book});
}

/// @nodoc
class __$$BookUnfinishedImplCopyWithImpl<$Res>
    extends _$StatsEventCopyWithImpl<$Res, _$BookUnfinishedImpl>
    implements _$$BookUnfinishedImplCopyWith<$Res> {
  __$$BookUnfinishedImplCopyWithImpl(
      _$BookUnfinishedImpl _value, $Res Function(_$BookUnfinishedImpl) _then)
      : super(_value, _then);

  /// Create a copy of StatsEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? book = null,
  }) {
    return _then(_$BookUnfinishedImpl(
      null == book
          ? _value.book
          : book // ignore: cast_nullable_to_non_nullable
              as Book,
    ));
  }
}

/// @nodoc

class _$BookUnfinishedImpl implements BookUnfinished {
  const _$BookUnfinishedImpl(this.book);

  @override
  final Book book;

  @override
  String toString() {
    return 'StatsEvent.bookUnfinished(book: $book)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BookUnfinishedImpl &&
            (identical(other.book, book) || other.book == book));
  }

  @override
  int get hashCode => Object.hash(runtimeType, book);

  /// Create a copy of StatsEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$BookUnfinishedImplCopyWith<_$BookUnfinishedImpl> get copyWith =>
      __$$BookUnfinishedImplCopyWithImpl<_$BookUnfinishedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadStats,
    required TResult Function(Book book) bookFinished,
    required TResult Function(Book book) bookUnfinished,
    required TResult Function() bookStarted,
    required TResult Function() bookUnstarted,
  }) {
    return bookUnfinished(book);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadStats,
    TResult? Function(Book book)? bookFinished,
    TResult? Function(Book book)? bookUnfinished,
    TResult? Function()? bookStarted,
    TResult? Function()? bookUnstarted,
  }) {
    return bookUnfinished?.call(book);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadStats,
    TResult Function(Book book)? bookFinished,
    TResult Function(Book book)? bookUnfinished,
    TResult Function()? bookStarted,
    TResult Function()? bookUnstarted,
    required TResult orElse(),
  }) {
    if (bookUnfinished != null) {
      return bookUnfinished(book);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadStats value) loadStats,
    required TResult Function(BookFinished value) bookFinished,
    required TResult Function(BookUnfinished value) bookUnfinished,
    required TResult Function(BookStarted value) bookStarted,
    required TResult Function(BookUnstarted value) bookUnstarted,
  }) {
    return bookUnfinished(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadStats value)? loadStats,
    TResult? Function(BookFinished value)? bookFinished,
    TResult? Function(BookUnfinished value)? bookUnfinished,
    TResult? Function(BookStarted value)? bookStarted,
    TResult? Function(BookUnstarted value)? bookUnstarted,
  }) {
    return bookUnfinished?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadStats value)? loadStats,
    TResult Function(BookFinished value)? bookFinished,
    TResult Function(BookUnfinished value)? bookUnfinished,
    TResult Function(BookStarted value)? bookStarted,
    TResult Function(BookUnstarted value)? bookUnstarted,
    required TResult orElse(),
  }) {
    if (bookUnfinished != null) {
      return bookUnfinished(this);
    }
    return orElse();
  }
}

abstract class BookUnfinished implements StatsEvent {
  const factory BookUnfinished(final Book book) = _$BookUnfinishedImpl;

  Book get book;

  /// Create a copy of StatsEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$BookUnfinishedImplCopyWith<_$BookUnfinishedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BookStartedImplCopyWith<$Res> {
  factory _$$BookStartedImplCopyWith(
          _$BookStartedImpl value, $Res Function(_$BookStartedImpl) then) =
      __$$BookStartedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BookStartedImplCopyWithImpl<$Res>
    extends _$StatsEventCopyWithImpl<$Res, _$BookStartedImpl>
    implements _$$BookStartedImplCopyWith<$Res> {
  __$$BookStartedImplCopyWithImpl(
      _$BookStartedImpl _value, $Res Function(_$BookStartedImpl) _then)
      : super(_value, _then);

  /// Create a copy of StatsEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$BookStartedImpl implements BookStarted {
  const _$BookStartedImpl();

  @override
  String toString() {
    return 'StatsEvent.bookStarted()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$BookStartedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadStats,
    required TResult Function(Book book) bookFinished,
    required TResult Function(Book book) bookUnfinished,
    required TResult Function() bookStarted,
    required TResult Function() bookUnstarted,
  }) {
    return bookStarted();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadStats,
    TResult? Function(Book book)? bookFinished,
    TResult? Function(Book book)? bookUnfinished,
    TResult? Function()? bookStarted,
    TResult? Function()? bookUnstarted,
  }) {
    return bookStarted?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadStats,
    TResult Function(Book book)? bookFinished,
    TResult Function(Book book)? bookUnfinished,
    TResult Function()? bookStarted,
    TResult Function()? bookUnstarted,
    required TResult orElse(),
  }) {
    if (bookStarted != null) {
      return bookStarted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadStats value) loadStats,
    required TResult Function(BookFinished value) bookFinished,
    required TResult Function(BookUnfinished value) bookUnfinished,
    required TResult Function(BookStarted value) bookStarted,
    required TResult Function(BookUnstarted value) bookUnstarted,
  }) {
    return bookStarted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadStats value)? loadStats,
    TResult? Function(BookFinished value)? bookFinished,
    TResult? Function(BookUnfinished value)? bookUnfinished,
    TResult? Function(BookStarted value)? bookStarted,
    TResult? Function(BookUnstarted value)? bookUnstarted,
  }) {
    return bookStarted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadStats value)? loadStats,
    TResult Function(BookFinished value)? bookFinished,
    TResult Function(BookUnfinished value)? bookUnfinished,
    TResult Function(BookStarted value)? bookStarted,
    TResult Function(BookUnstarted value)? bookUnstarted,
    required TResult orElse(),
  }) {
    if (bookStarted != null) {
      return bookStarted(this);
    }
    return orElse();
  }
}

abstract class BookStarted implements StatsEvent {
  const factory BookStarted() = _$BookStartedImpl;
}

/// @nodoc
abstract class _$$BookUnstartedImplCopyWith<$Res> {
  factory _$$BookUnstartedImplCopyWith(
          _$BookUnstartedImpl value, $Res Function(_$BookUnstartedImpl) then) =
      __$$BookUnstartedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BookUnstartedImplCopyWithImpl<$Res>
    extends _$StatsEventCopyWithImpl<$Res, _$BookUnstartedImpl>
    implements _$$BookUnstartedImplCopyWith<$Res> {
  __$$BookUnstartedImplCopyWithImpl(
      _$BookUnstartedImpl _value, $Res Function(_$BookUnstartedImpl) _then)
      : super(_value, _then);

  /// Create a copy of StatsEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$BookUnstartedImpl implements BookUnstarted {
  const _$BookUnstartedImpl();

  @override
  String toString() {
    return 'StatsEvent.bookUnstarted()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$BookUnstartedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loadStats,
    required TResult Function(Book book) bookFinished,
    required TResult Function(Book book) bookUnfinished,
    required TResult Function() bookStarted,
    required TResult Function() bookUnstarted,
  }) {
    return bookUnstarted();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loadStats,
    TResult? Function(Book book)? bookFinished,
    TResult? Function(Book book)? bookUnfinished,
    TResult? Function()? bookStarted,
    TResult? Function()? bookUnstarted,
  }) {
    return bookUnstarted?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loadStats,
    TResult Function(Book book)? bookFinished,
    TResult Function(Book book)? bookUnfinished,
    TResult Function()? bookStarted,
    TResult Function()? bookUnstarted,
    required TResult orElse(),
  }) {
    if (bookUnstarted != null) {
      return bookUnstarted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(LoadStats value) loadStats,
    required TResult Function(BookFinished value) bookFinished,
    required TResult Function(BookUnfinished value) bookUnfinished,
    required TResult Function(BookStarted value) bookStarted,
    required TResult Function(BookUnstarted value) bookUnstarted,
  }) {
    return bookUnstarted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(LoadStats value)? loadStats,
    TResult? Function(BookFinished value)? bookFinished,
    TResult? Function(BookUnfinished value)? bookUnfinished,
    TResult? Function(BookStarted value)? bookStarted,
    TResult? Function(BookUnstarted value)? bookUnstarted,
  }) {
    return bookUnstarted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(LoadStats value)? loadStats,
    TResult Function(BookFinished value)? bookFinished,
    TResult Function(BookUnfinished value)? bookUnfinished,
    TResult Function(BookStarted value)? bookStarted,
    TResult Function(BookUnstarted value)? bookUnstarted,
    required TResult orElse(),
  }) {
    if (bookUnstarted != null) {
      return bookUnstarted(this);
    }
    return orElse();
  }
}

abstract class BookUnstarted implements StatsEvent {
  const factory BookUnstarted() = _$BookUnstartedImpl;
}
